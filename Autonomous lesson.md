### What is autonomous?
The first 15 seconds of each match is the autonomous period. During this, robots run off of pre-programmed instructions and sensors. Human operators cannot interact with the robot during this time, execpt by pressing the E-Stop button.


### Why is it important?
- For most games, you can score more points per item during autonomous than during teleop. (e.g. 2 points/sec for switch and scale)
- Certain scoring actions can only be performed during autonomous. (e.g. crossing line for 5 points)
- Many games allow you to gain 1 Ranking Point during autonomous only (e.g. 3 robots crossing line + 1 cube in switch)
- Parts of the autonomous routine can be reused during teleop to improve the driver’s speed and accuracy. (e.g. automatically moving elevator to correct height for scoring in scale)


### Overview of autonomous code
Each autonomous routine is a single `Command` or `CommandGroup` (more on that later). It starts at the start of autonomous period and ends when finished or interrupted, usually at the end of autonomous period.

`CommandGroups` contain one or more `Commands`, which are run in a specific order.

- `runSequential(Command command)`: runs "command" and waits until completion to run the next `Command`
- `runParallel(Command command)`: runs "command" but does not wait before running the next `Command`

Here’s a sample from our offseason code:

```java
public class MiddleToRight extends CommandGroup {
	public MiddleToRight() {
		addSequential(new Move(0.5, 0.66));
		addSequential(new Turn(45.0));
		addSequential(new Move(0.5, 1.7));
		addSequential(new Turn(-45.0));
		addSequential(new MoveToWall(0.5));
		addSequential(new Move(0.33, 0.25));
		addSequential(new LowerArm());
		addSequential(new DropCube());
	}
}
```

Each item (`Move`, `Turn`, `LowerArm`, etc.) is a `Command` or `CommandGroup` that performs a single action. This is done in one of two ways:

- using timeouts to stop the command at a certain time (e.g. `Move`)
- using sensors to determine when the action is complete (e.g. `Turn`, `MoveToWall`)

Timeouts work for simple actions and are quick to implement, but they assume that there are no external factors changing each run. In reality, the type of carpet, wear on the wheels, battery voltage, etc. can alter the proper timings and cause inaccuracies at competition. There are ways to mitigate these, but sensor-based routines can correct themselves and are generally better.

### What sensors can we use?

- Encoders: measure rotation across any angle, but with more software work required
- Potentiometers: measure rotation within a certain angle
- Limit switches: basic switch used to stop motion at a hard limit
- IMU: contains a gyroscope (angular position), accelerometer (linear acceleration), and compass
- Distance sensor: measure distance from a flat surface
- Color sensor: measure color value


### Closed-loop control systems: Repeatable, self-correcting movements

Closed-loop control systems are mathematical equations that outputs motor values based on sensor feedback. To explain this, we need to define a few terms first:

- Open-loop control: setting motor values without sensor feedback
- Closed-loop control: setting motor values with sensor feedback
- Setpoint: the sensor value that a PID loop attempts to reach
- Error: the difference betweeen the current sensor value and the setpoint
- Steady-state error: an error value that remains constant over a large period of time
- Output: a motor value generated by a open- or closed-loop; motor values are in the range [-1, 1] for FRC, so anything outside that range will be reduced to -1 or 1

Let's say that we need our robot to turn 45 degrees. The simplest way to do this with closed-loop control is to turn at a constant speed until our robot's gyroscope measures 45 degrees. Let's create a simple `Command` that will do this:

```java
public class Turn45Degrees extends Command {
    public Turn45Degrees() {
        requires(Robot.driveTrain);
    }
    
    public void initialize() {
        Robot.gyroscope.tare();  // sets the current position as 0 degrees
    }
    
    public void execute() {
        Robot.driveTrain.drive(0.0, 1.0);  // drive(linear, rotation)
    }
    
    public boolean isFinished() {
        return Robot.gyroscope.getYaw() >= 45.0;
    }
    
    public void end() {
        Robot.driveTrain.drive(0.0, 0.0);
    }
    
    public void interrupted() {
        end();  // ensures that all cleanup still happens if this Command is interrupted
    }
}
```

This program works, but it doesn't take into account that the robot will not instantly stop moving. Motor braking cannot fully counteract the rotational momentum of the robot, so it will always overshoot its target. Let's add a little more complexity to the code to make it turn backwards if it overshoots:

```java
public class Turn45Degrees extends Command {
    // assume that all methods not shown are unchanged
    public void execute() {
        double output;
        if (Robot.gyroscope.getYaw() < 45.0)
            output = 1.0;
        if (Robot.gyroscope.getYaw() > 45.0)
            output = -1.0;
        Robot.driveTrain.drive(0.0, output);
    }
    
    public boolean isFinished() {
        return Robot.gyroscope.getYaw() == 45.0;
    }
}
```

The problem here is that this `Command` will never finish. We will never exactly reach 45 degrees, so the robot will oscillate around the setpoint indefinitely. A better solution to this is to use a PID (proportional, integral, derivative) loop. This closed loop uses calculus to smoothly reach the setpoint. Before we jump into the deep end, let's first try only using the proportional term of a PID loop.

```java
public class Turn45Degrees extends Command {
    private static double kP = 0.5;  // this is the P constant
    private static double acceptableError = 1.0;  // defines how far from the setpoint we can be
    
    // assume that all methods not shown are unchanged
    public void execute() {
        double output;
        double error = 45.0 - Robot.gyroscope.getYaw();
        output = kP * error;
        Robot.driveTrain.drive(0.0, output);
    }
    
    public boolean isFinished() {
        return (abs(45.0 - Robot.gyroscope.getYaw()) <= acceptableError);
    }
}
```

This is a simple P loop that will turn the robot 45 degrees. This won't work out of the box; we have to tune `kP` by repeatedly testing the loop and changing the constant until we get the response we want.

This system works well enough on its own. For example, we used similar code in [our offseason autonomous routines](https://github.com/1777TheVikings/FRC1777-2018VSCodeTest/blob/master/src/main/java/frc/robot/commands/autonomous/components/Turn.java) with few issues. However, our acceptable error was kept as high as 2 degrees because P loops will always either oscillate or undershoot.

Let's pretend that `acceptableError` was set to zero. If we set `kP` low, we will slow down so much as we approach the setpoint that we will eventually be turning too slow to overcome friction. If we set `kP` to high, one of two things will happen:

- The robot constantly overshoots the setpoint, but slightly less on each cycle. The robot slows down because of this, eventually turning too slow to overcome friction.
- The robot constantly overshoots the setpoint, but slightly more on each cycle. The robot constantly turns further and faster than before until the autonomous period ends or, in the case of tall robots, it spins fast enough to tip over.

The best case is to reduce `kP` until it undershoots, but this introduces a steady-state error. We can eliminate the error by adding an integral term to form a PI loop. This does require some calculus, but the simplest explanation is that the integral of a graph is the area under the curve. In our case, this will slowly increase the output to remove any steady-state error we encounter.

```java
public class Turn45Degrees extends Command {
    private static double kP = 0.5;
    private static double kI = 0.05;  // the I constant
    private static double acceptableError = 1.0;
    private double integral = 0.0;  // area under the graph of error vs. time
    private static double timeStep = 0.02;  // the time between executions of execute(); always equals 20ms in FRC
    
    // assume that all methods not shown are unchanged
    public void execute() {
        double output;
        double error = 45.0 - Robot.gyroscope.getYaw();
        this.integral += (error * timeStep);
        output = kP * error + kI * this.integral;
        Robot.driveTrain.drive(0.0, output);
    }
    
    public boolean isFinished() {
        return (abs(45.0 - Robot.gyroscope.getYaw()) <= acceptableError);
    }
}
```

After tuning `kI`, the robot should now smoothly turn to 45 degrees with high precision. However, the addition of the `kI` term may make the robot overshoot and oscillate more. If we want to eliminate that, we can add the derivative term to form a full PID loop. Derivatives also involve calculus, but the simple explanation is that a derivative is the slope of a curve at a specific point. For us, it signifies the change in the error value and applies a brake to ensure that we don't overshoot.

```java
public class Turn45Degrees extends Command {
    private static double kP = 0.5;
    private static double kI = 0.05;
    private static double kD = 0.005;  // the D term
    private static double acceptableError = 1.0;
    private double integral = 0.0;
    private static double timeStep = 0.02;
    private double lastError = 0.0;  // the previous error reading
    
    // assume that all methods not shown are unchanged
    public void execute() {
        double output;
        double error = 45.0 - Robot.gyroscope.getYaw();
        this.integral += (error * timeStep);
        double derivative = (error - this.lastError) / timeStep;
        output = kP * error + kI * this.integral = kD * derivative;
        Robot.driveTrain.drive(0.0, output);
    }
    
    public boolean isFinished() {
        return (abs(45.0 - Robot.gyroscope.getYaw()) <= acceptableError);
    }
}
```

This is a PID loop that will allow us to smoothly turn 45 degrees without overshooting or excessively oscillating. There are feedforward (adding a constant value to every output) terms that can be added for controlling elevators or other systems where you know what the output should always be close to, but this is the bulk of the math. For more information on PID, feedforward, and how to tune constants, I would recommend reading [this article from "FRC Programming Done Right"](https://frc-pdr.readthedocs.io/en/latest/control/pid_control.html).